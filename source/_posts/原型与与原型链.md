---
title: 原型与与原型链
date: 2019-02-18 15:53:16
tags: 
        - konwledge
        - js 

categories: 
        - konwledge
        - js
---
    
    立个flag，新的一年开始了，我表示很开心。

* # 深入理解原型与与原型链
[参考1]https://www.cnblogs.com/dengpeng1004/p/5317245.html

[参考2]https://blog.csdn.net/baidu_31333625/article/details/54613438

[JS原型链与继承别再被问倒了]https://juejin.im/post/58f94c9bb123db411953691b (主要)

[从prototype与__proto__窥探JS继承之源]https://juejin.im/post/58f9d0290ce46300611ada65(主要)
  ````
      JavaScript是一门完全面向对象的语言，如果想要更好地使用JavaScript的面向对象系统，原型和原型链就是个绕不开的话题。 
      
  ````
### 构造函数  原型 实例的关系
       每个构造函数(constructorFunction)，都有一个原型对象（prototype）,每一个原型对象都包含一个指向构造函数的指针(通过内置的constructor属性)，每一个实例（instanc2)对象都包含一个执行原型对象的内部指针。
### js 原型链查找规则
       如果引用实例对象（instance)的某个属性或者方法，会首先在对象内部查找，如果查找不到，会到该对象的原型链中寻找，原型链的顶级为Object.prototype。
### 原型对象指向另一个构造函数的实例 
  
       说明: 原型对象的说法会带来一定的混淆，（严格来说 Function.prototype的类型为function，但因为只有Function的原型为函数，并且在js中函数也是一种对象，所以此处及其下文中，统一称为原型对象，诸如此类说法，统一三个名称： 构造函数 - constructor，原型对象 xxx.prototype，实例对象 instance）
 回到我们本节讨论的话题: 原型对象指向另一个构造函数的实例,即：当constructor1.prototype = instance2
 ````javascript  
    讨论的前提条件： 现有构造函数constructor1，并且由该函数构造出来的实例对象instance1，同理也有constcutor2以及由其构造出来的instance2. 并且constructor1.prototype = instance2
    如果试图引用constructor1构造的实例instance1的某个属性或方法，则会由如下场景：
    1、首先在实例对象instance1内部属性或者方法中查找一遍，找到则停止执行以下步骤
    2、如果1找不到，接着会在实例对象的原型链中寻找，即前往实例对象的构造函数的原型对象中寻找，即：会在instance1.__proto__(constructor1.prototype)中找一遍，此时发现，constructor1.prototype实际上就是instance2，也就是在instance2中查找，这样从一个实例中查找，跳到了另一个实例中查找，两个实例间就建立起了原型链的关系(实际上是通过对象内部有且必有的__proto__属性)。如果找到则停止执行以下步骤
    3、如果instance2中仍旧没有找到，程序会继续在instance2.__proto__(constructor2.prototype)寻找，以次类推，如果还没有找到，还会继续沿着存在诸如constructor2.prototype = instance3(constructor3构造生成),
    constructor3.prototype = instance4(constructor4构造生成)..... 此类关系的链结构中查找，直到原型对象的顶端Object.prototype
    搜索轨迹: instance1--> instance2 --> constructor2.prototype.......-->Object.prototype
    这种搜多轨迹形成一条长链，并且是由prototype或者说__proto__属性充当链接作用，于是就把这种实例对象与原型对象之间的链条叫做原型链。

 ````
 下边举个例子
  ```javascript
  function Father() {
    this.fatherName = 'father'
    this.age = '40'
  }
  Father.prototype.getFatherName = function() {
    return console.log(`this is fatherName ${this.fatherName}`)
  }
  function Son() {
    this.sonName = 'son'
  }
  // Son 继承Father
  Son.prototype = new Father() // Son.prototype被重写，导致Son.prototype.constructor一并被改写为构造函数Father
  Son.prototype.getSonName = function() {
    return console.log(`this is sonName ${this.sonName}`)
  }
  var instance = new Son()
  console.log(instance.getFatherName()) // this is fatherName father
  console.log(Son.prototype.constructor) // Father() {this.fatherName = 'father'}
  Son.prototype.constructor = Son //  将Son的原型对象的constructor属性重置回Son
  console.log(Son.prototype.constructor) // Son() {this.sonName = 'son'}
  console.log(instance.age) // 40 继承了Father的age属性
  ```
上边例子可以看到，instance通过原型链找到了Father原型对象中的getFatherName方法，并且也继承了Father该构造函数中声明的age属性

      
